Metadata-Version: 2.4
Name: evoalign
Version: 0.1.0
Summary: EvoAlign schemas, invariants, and governance tooling
Author-email: benldt <bldt@proton.me>
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: pyyaml>=6.0
Requires-Dist: jsonschema>=4.23.0

# EvoAlign v2: Schemas & CI Invariants

> **From philosophy to engineering**: This package provides the formal schemas and CI enforcement that make EvoAlign a system that can refuse to accept changes that violate its safety invariants.

## Overview

This implementation provides:

1. **JSON Schemas** for all core EvoAlign data structures
2. **CI Invariant Checks** that block PRs violating safety boundaries
3. **Example artifacts** demonstrating proper usage

## Non-Negotiables: Testing Discipline And Maintainability

- **100%** Line/Branch/Function/Statement coverage required

- **350 LOC Limit**: Hard cap per source file (tests/types exempt). Enforce via CI. Split modules aggressively.

## Schemas

All schemas follow [JSON Schema Draft 2020-12](https://json-schema.org/draft/2020-12/schema).

### Core Schemas

| Schema | Purpose | EvoAlign Section |
|--------|---------|------------------|
| `SafetyContract.schema.json` | Hazards, severities, tolerances, disallowed events | §3 |
| `ContextLattice.schema.json` | Context lattice registry and semantics | §4 |
| `RiskCurveFit.schema.json` | Risk model parameters with uncertainty | §5.1-5.4 |
| `RiskSweepManifest.schema.json` | Risk sweep manifests backing fits | §5.1 |
| `OversightPlan.schema.json` | Computed oversight allocations | §5.2, §5.7 |
| `EvalRunManifest.schema.json` | Evaluation run manifests | §6 |
| `SuiteRegistry.schema.json` | Suite registry for provenance | §6 |
| `SuiteSet.schema.json` | Suite set manifests | §6 |
| `DatasetManifest.schema.json` | Dataset manifest provenance | §6 |
| `SecretSuiteHashRegistry.schema.json` | Secret suite fingerprint registry | §6 |
| `LineageLedgerEntry.schema.json` | Lineage ledger entry (append-only) | §8.4 |
| `ChronicleEntry.schema.json` | Chronicle anomaly event | §10 |
| `PublicKeyRegistry.schema.json` | Public key registry for signatures | §12.3 |
| `DampingConfig.schema.json` | Stability controls configuration | §5.5-5.6 |
| `MonitoringConfig.schema.json` | Operational monitoring configuration | §11.1-11.3 |
| `AAR.schema.json` | Alignment Assurance Report | §13 |

### Schema Relationships

```
ContextLattice ──▶ context_class semantics for contracts, sweeps, fits, plans

SuiteRegistry ──▶ SuiteSet ─┐
DatasetManifest ───────────┴─▶ EvalRunManifest ─▶ RiskSweepManifest ─▶ RiskCurveFit ─▶ OversightPlan ─▶ AAR

SecretSuiteHashRegistry ─▶ Secrecy invariant + AAR reproducibility hashes

LineageLedgerEntry ─▶ stage gates, promotions, retirements (append-only chain)
ChronicleEntry ─▶ anomaly events, incidents, drift detection ─▶ AAR known_gaps

PublicKeyRegistry ─▶ key verification for signatures (optional tamper evidence)

DampingConfig ─▶ stability controls bound to AAR stability_controls claims
MonitoringConfig ─▶ alerting thresholds bound to AAR operational_controls claims
```

## CI Invariants

Per EvoAlign v2 §14.3, these invariants MUST pass for any change to merge.

### Invariant Summary

| Invariant | Rule | Failure Consequence |
|-----------|------|---------------------|
| **SCHEMA_VALIDATION** | Artifacts validate against their declared schemas | PR blocked |
| **SECRET_REGISTRY_INTEGRITY** | Secret hash registry completeness + hash/root integrity | PR blocked |
| **SECRECY** | Secret fingerprints do not appear in protected artifacts | PR blocked |
| **PROMOTION** | Lineage promotions require gates_passed evidence | PR blocked |
| **SALVAGE** | Salvage usage requires certified transfer tests + taint tags | PR blocked |
| **ROLLBACK** | Deployments include certified rollback target | PR blocked |
| **CONTRACT** | Safety Contract changes require RFC + approvals | PR blocked |
| **CONTEXT_LATTICE_GOVERNANCE** | Lattice changes require RFC + approvals | PR blocked |
| **CONTEXT_REGISTRY** | All context_class IDs must appear in lattice registry | PR blocked |
| **BUDGET_SOLVENCY** | Oversight plans satisfy tolerances under conservative fits | PR blocked |
| **EVIDENCE_GOVERNANCE** | Fits/sweeps/runs/sets include RFC + signed approvals | PR blocked |
| **FIT_PROVENANCE_COMPLETE** | Fit provenance required fields are present | PR blocked |
| **FIT_PROVENANCE_INTEGRITY** | Fit provenance hashes/manifests/commits verified | PR blocked |
| **FIT_PLAN_AAR_CONSISTENCY** | Plans/AARs bind to fit hashes + reproducibility | PR blocked |
| **AAR_EVIDENCE_CHAIN** | AAR contract/secret hashes + previous AAR chain verified | PR blocked |
| **LINEAGE_INTEGRITY** | Lineage entries have valid provenance and chain | PR blocked |
| **CHRONICLE_GOVERNANCE** | Chronicle entries reference valid AARs | PR blocked |
| **TAMPER_EVIDENCE** | Merkle roots and key references verified when present | PR blocked |
| **RUNTIME_CONFIG** | Runtime configs match AAR stability/monitoring claims | PR blocked |

### Running Invariant Checks

```bash
# Create and activate repo-local virtualenv (recommended)
python3 -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install pyyaml jsonschema coverage

# Set repo root + python path
export REPO_ROOT=/path/to/evoalign
export PYTHONPATH=/path/to/evoalign

# Run all invariants
python ci/invariants/check_invariants.py

# Run tests for the invariant checker itself
python -m unittest discover -s tests

# Enforce 100% coverage and 350 LOC cap
python -m coverage run --branch --source=ci/invariants,evoalign -m unittest discover -s tests
python -m coverage report --fail-under=100
python ci/invariants/loc_check.py
```

### Installation (CLI)

```bash
pip install -e .
evoalign --help
```

### CLI Tooling

```bash
# Canonical hash for a data file
evoalign hash aars/aar_v0_1.json

# Verify the evidence chain locally
evoalign verify-chain --repo-root .

# Scaffold a new AAR with previous hash
evoalign new-aar --previous "$(evoalign hash aars/aar_v0_1.json)"
```

### CI Pipeline

The GitHub Actions pipeline (`ci/pipelines/invariants.yaml`) runs:

1. **Schema validation** - Validates schemas + data files via `schema_validation.py`
2. **Core invariants** - Runs the full invariant suite
3. **Context inventory** - Emits context usage artifact
4. **Coverage + LOC gates** - Enforces 100% coverage and 350 LOC cap
5. **Secrecy boundary** - Generates secrecy audit artifact
6. **Salvage safety** - Verifies salvage artifact certifications
7. **Contract governance** - Ensures RFC and approval requirements

All jobs must pass for the **Invariant Gate** to allow merge.

## Directory Structure

```
.
├── aars/
│   └── aar_v0_1.json                 # Example AAR
├── chronicle/
│   └── events/                       # Chronicle anomaly entries
├── ci/
│   ├── invariants/                   # Invariant checks + tooling
│   └── pipelines/invariants.yaml     # GitHub Actions config
├── contracts/
│   ├── context_lattice/              # Context lattice registry
│   └── safety_contracts/             # Safety contract(s)
├── control_plane/
│   ├── runtime/              # Damping + monitoring configs
│   ├── evals/
│   │   ├── datasets/manifests/       # Dataset manifests
│   │   ├── runs/                     # Eval run manifests
│   │   └── suites/                   # Suite registry + sets + hash registries
│   └── governor/
│       ├── oversight_plans/          # Oversight plans
│       ├── risk_fits/                # Risk fits
│       └── sweeps/                   # Risk sweep manifests
├── docs/                             # Supporting documentation
├── evoalign/                         # Lattice + provenance utilities
├── lineage/                          # Lineage ledger entries (append-only)
├── schemas/                          # JSON Schemas
└── tests/                            # Unit tests
```

## Usage Examples

### Validating a Safety Contract

```python
import json
from jsonschema import validate

with open("schemas/SafetyContract.schema.json") as f:
    schema = json.load(f)

with open("contracts/safety_contracts/safety_contract_v0_4.yaml") as f:
    import yaml
    contract = yaml.safe_load(f)

validate(instance=contract, schema=schema)
print("Contract is valid!")
```

### Validating an AAR

```python
import json
from jsonschema import validate

with open("schemas/AAR.schema.json") as f:
    schema = json.load(f)

with open("aars/aar_v0_1.json") as f:
    aar = json.load(f)

validate(instance=aar, schema=schema)
print("AAR is valid!")
```

### Checking Invariants Programmatically

```python
from pathlib import Path
from ci.invariants.check_invariants import run_all_invariants

results = run_all_invariants(Path("/path/to/repo"))

if results["all_passed"]:
    print("All invariants passed!")
else:
    for r in results["results"]:
        if r["result"] == "FAIL":
            print(f"FAILED: {r['name']} - {r['message']}")
```

## Key Design Decisions

### Why JSON Schema?

- **Standardized**: Widely supported validation tooling
- **Machine-readable**: Enables automated enforcement
- **Self-documenting**: Schema IS the documentation
- **Language-agnostic**: Works with any language/toolchain

### Why CI Invariants?

- **Shift left**: Catch violations before merge, not in production
- **Automated**: No human gatekeeping bottleneck
- **Auditable**: Every check is logged
- **Immutable**: Can't be bypassed by "just this once"

### Conservative Defaults

The invariant checks follow a "fail-closed" philosophy:
- Missing evidence = FAIL (not skip)
- Ambiguous state = FAIL (not pass)
- Unknown artifacts = FAIL (not ignore)

## Extending the System

### Adding a New Invariant

1. Create a new class inheriting from `InvariantChecker`
2. Implement the `check()` method returning `InvariantCheck`
3. Add to `ALL_INVARIANTS` list
4. Add tests in `tests/invariants/`

```python
class MyNewInvariant(InvariantChecker):
    def check(self) -> InvariantCheck:
        # Your check logic here
        if violation_found:
            return InvariantCheck(
                name="MY_NEW",
                result=InvariantResult.FAIL,
                message="Violation detected",
                details={"violations": [...]}
            )
        return InvariantCheck(
            name="MY_NEW",
            result=InvariantResult.PASS,
            message="Check passed"
        )
```

### Adding a New Schema

1. Create `YourSchema.schema.json` in `schemas/`
2. Use `$id` for canonical URI
3. Add to SCHEMA_MAP in CI pipeline for validation
4. Document in this README

## Documentation

Key docs in `docs/`:

- `docs/CONTEXT_LATTICE.md` — Context lattice semantics and coverage rules
- `docs/PROVENANCE_HASHING.md` — Canonical hashing + provenance hardening
- `docs/SECRECY_HASH_REGISTRY.md` — Secret hash registry and enforcement
- `docs/LINEAGE_CHRONICLE.md` — Lineage ledger and chronicle entries
- `docs/TAMPER_EVIDENCE.md` — Merkle roots and signature verification
- `docs/RUNTIME_GUARDRAILS.md` — Damping and monitoring configuration
- `docs/HANDOFF_HARDENING.md` — Schema validation and CLI tooling

## Relationship to EvoAlign v2 Spec

This implementation covers:

- ✅ §3: Safety Contract (hazards, severities, tolerances)
- ✅ §4: Context lattice semantics and governance
- ✅ §5: Risk modeling, sweeps, fits, and oversight planning
- ✅ Fit provenance hardening (manifests, hashing, fit/plan/AAR bindings)
- ✅ §6: Evaluation provenance + secrecy enforcement
- ✅ §9: Salvage with taint tracking (invariants)
- ✅ §11.4: Rollback requirements (invariants)
- ✅ §12.2: Contract/lattice governance (invariants)
- ✅ §13: AAR structure with hash bindings
- ✅ §14.3: CI-enforceable invariants
- ✅ §8.4: Lineage ledger schema + example artifacts
- ✅ §10: Chronicle schema (anomaly-focused) + example artifacts
- ✅ §12.3: Cryptographic tamper evidence (Merkle roots + optional signatures)
- ✅ §5.5-5.6: Stability controls and damping (config schemas + invariant)
- ✅ §11.1-11.3: Operational monitoring (config schemas + invariant)

Not yet implemented (future work):

- ⬜ §7: Experience Graph schema

## License

See LICENSE file in repository root.

---

**Remember**: The repo itself is now a guardrail. It can refuse changes that violate safety boundaries. That's the line from philosophy to engineering.
